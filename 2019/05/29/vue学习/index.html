<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="vue学习"><meta name="keywords" content="JS"><meta name="author" content="陆阿狸"><meta name="copyright" content="陆阿狸"><title>vue学习 | 陆阿狸的博客</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-9138439391803182',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-141300443-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC-与-MVVM-的区别"><span class="toc-number">1.</span> <span class="toc-text">MVC 与 MVVM 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-实例"><span class="toc-number">2.</span> <span class="toc-text">Vue 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双向数据绑定"><span class="toc-number">3.</span> <span class="toc-text">双向数据绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态添加数据的注意点"><span class="toc-number">4.</span> <span class="toc-text">动态添加数据的注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步-DOM-更新"><span class="toc-number">5.</span> <span class="toc-text">异步 DOM 更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-指令"><span class="toc-number">6.</span> <span class="toc-text">Vue 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#样式处理-class-和-style"><span class="toc-number">7.</span> <span class="toc-text">样式处理 -class 和 style</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#过滤器-filter"><span class="toc-number">8.</span> <span class="toc-text">过滤器 filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按键值修饰符"><span class="toc-number">9.</span> <span class="toc-text">按键值修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#监视数据变化-watch"><span class="toc-number">10.</span> <span class="toc-text">监视数据变化 - watch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例生命周期"><span class="toc-number">11.</span> <span class="toc-text">实例生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期介绍"><span class="toc-number">11.1.</span> <span class="toc-text">生命周期介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子函数-beforeCreate"><span class="toc-number">11.2.</span> <span class="toc-text">钩子函数 - beforeCreate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子函数-created"><span class="toc-number">11.3.</span> <span class="toc-text">钩子函数 - created()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子函数-beforeMounted"><span class="toc-number">11.4.</span> <span class="toc-text">钩子函数 - beforeMounted()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子函数-mounted"><span class="toc-number">11.5.</span> <span class="toc-text">钩子函数 - mounted()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子函数-beforeUpdated"><span class="toc-number">11.6.</span> <span class="toc-text">钩子函数 - beforeUpdated()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子函数-updated"><span class="toc-number">11.7.</span> <span class="toc-text">钩子函数 - updated()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子函数-beforeDestroy"><span class="toc-number">11.8.</span> <span class="toc-text">钩子函数 - beforeDestroy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子函数-destroyed"><span class="toc-number">11.9.</span> <span class="toc-text">钩子函数 - destroyed()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-number">12.</span> <span class="toc-text">axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义组件"><span class="toc-number">13.</span> <span class="toc-text">自定义组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件"><span class="toc-number">14.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局组件"><span class="toc-number">14.1.</span> <span class="toc-text">全局组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部组件"><span class="toc-number">14.2.</span> <span class="toc-text">局部组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is特性"><span class="toc-number">14.3.</span> <span class="toc-text">is特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件通讯"><span class="toc-number">15.</span> <span class="toc-text">组件通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#父组件到子组件"><span class="toc-number">15.1.</span> <span class="toc-text">父组件到子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子组件到父组件"><span class="toc-number">15.2.</span> <span class="toc-text">子组件到父组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非父子组件通讯"><span class="toc-number">15.3.</span> <span class="toc-text">非父子组件通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内容分发"><span class="toc-number">15.4.</span> <span class="toc-text">内容分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取组件（或元素）-refs"><span class="toc-number">15.5.</span> <span class="toc-text">获取组件（或元素） - refs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA-单页应用程序"><span class="toc-number">16.</span> <span class="toc-text">SPA -单页应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPA：-Single-Page-Application"><span class="toc-number">16.1.</span> <span class="toc-text">SPA： Single Page Application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由"><span class="toc-number">16.2.</span> <span class="toc-text">路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端模块化"><span class="toc-number">17.</span> <span class="toc-text">前端模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模块的概念"><span class="toc-number">17.1.</span> <span class="toc-text">模块的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块化解决的问题"><span class="toc-number">17.2.</span> <span class="toc-text">模块化解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS实现模块化的规范"><span class="toc-number">17.3.</span> <span class="toc-text">JS实现模块化的规范</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">陆阿狸</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/sky.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">陆阿狸的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">vue学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-31</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JS/">JS</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>记录 Vue 的学习, Vue -渐进式JavaScript框架</p>
</blockquote>
<a id="more"></a>
<h2 id="MVC-与-MVVM-的区别"><a href="#MVC-与-MVVM-的区别" class="headerlink" title="MVC 与 MVVM 的区别"></a>MVC 与 MVVM 的区别</h2><p>MVC 是指 Model View Controller（模型-视图-控制器），是一种 Web 架构的模式。<br>MVVM 是指 Model-View-ViewModel，是一种基于前端开发的架构模式。<br>在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。<br>MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。</p>
<h2 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h2><p><b>注意点：</b></p>
<ol>
<li>需要先在data中声明数据，再使用数据</li>
<li>可以通过 vm.$data 访问到data中的所有属性，或者 vm.msg</li>
</ol>
<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响。通过 getter 和 setter 来实现双向绑定</p>
<h2 id="动态添加数据的注意点"><a href="#动态添加数据的注意点" class="headerlink" title="动态添加数据的注意点"></a>动态添加数据的注意点</h2><p>只有 data 中的数据才是响应式的，动态添加进来的数据默认为非响应式<br>可以通过以下方式实现动态添加数据的响应式</p>
<ol>
<li>Vue.set(object, key, value) - 适用于添加单个属性</li>
<li>Object.assign() - 适用于添加多个属性</li>
</ol>
<h2 id="异步-DOM-更新"><a href="#异步-DOM-更新" class="headerlink" title="异步 DOM 更新"></a>异步 DOM 更新</h2><ul>
<li>说明：Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM</li>
<li>优势：可以去除重复数据，对于避免不必要的计算和避免重复 DOM 操作上，非常重要</li>
<li>如果需要那到更新后 DOM 中的数据，则需要通过 Vue.nextTick(callback)：在DOM更新后，执行某个操作（属于DOM操作） 实例调用 vm.$nextTick(function () {})</li>
</ul>
<h2 id="Vue-指令"><a href="#Vue-指令" class="headerlink" title="Vue 指令"></a>Vue 指令</h2><p>Vue 指令一般是带有 v- 前缀的特殊属性，当表达式的值改变是，将其产生的连带影响，响应式地作用于 DOM</p>
<ul>
<li>v-text: 更新 DOM 对象的 textContent</li>
<li>v-html: 更新 DOM 对象的 innerHTML</li>
<li>v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>
<li>v-on: 绑定事件， 绑定的事件定义在 methods 中</li>
<li>事件修饰符<ul>
<li>.stop 阻止冒泡，调用 event.stopPropagation()</li>
<li>.prevent 阻止默认行为，调用 event.preventDefault()</li>
<li>.capture 添加事件侦听器时使用事件捕获模式</li>
<li>.self 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件</li>
<li>.once 事件只触发一次</li>
</ul>
</li>
<li>v-model: 在表单元素上创建双向数据绑定，监听用户的输入事件以更新数据</li>
<li>v-for: 基于源数据多次渲染元素或模板块</li>
<li>key属性: 使用 v-for 的时候提供 key 属性，以获得性能提升。使用 key，Vue 会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li>
</ul>
<h2 id="样式处理-class-和-style"><a href="#样式处理-class-和-style" class="headerlink" title="样式处理 -class 和 style"></a>样式处理 -class 和 style</h2><p>使用方式：v-bind:class=”expression” or :class=”expression”， 表达式的类型：字符串、数组、对象（重点）</p>
<ul>
<li><p>v-if 和 v-show</p>
<ul>
<li>v-if: 根据表达式的值的真假条件，销毁或重建元素</li>
<li>v-show: 根据表达式之真假值，切换元素的 display CSS 属性</li>
</ul>
</li>
<li><p>提升性能: v-pre<br>vue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译</p>
</li>
<li><p>提升性能：v-once<br>vue只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>
</li>
</ul>
<h2 id="过滤器-filter"><a href="#过滤器-filter" class="headerlink" title="过滤器 filter"></a>过滤器 filter</h2><p>文本数据格式化</p>
<ul>
<li>全局过滤器<br>通过全局方式创建的过滤器，在任何一个vue实例中都可以使用。使用全局过滤器的时候，需要先创建全局过滤器，再创建Vue实例。显示的内容由过滤器的返回值决定</li>
<li>局部过滤器<br>局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用</li>
</ul>
<h2 id="按键值修饰符"><a href="#按键值修饰符" class="headerlink" title="按键值修饰符"></a>按键值修饰符</h2><p>在监听键盘事件时，Vue 允许为 v-on 在监听键盘事件时添加关键修饰符。例如@keyup.13=”submit”</p>
<h2 id="监视数据变化-watch"><a href="#监视数据变化-watch" class="headerlink" title="监视数据变化 - watch"></a>监视数据变化 - watch</h2><p>watch是一个对象，键是需要观察的表达式，值是对应回调函数，当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作</p>
<h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><p>所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。<br>实例生命周期也叫做：组件生命周期</p>
<h3 id="生命周期介绍"><a href="#生命周期介绍" class="headerlink" title="生命周期介绍"></a>生命周期介绍</h3><p>一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期<br>生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！<br>注意：</p>
<ul>
<li>Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可</li>
<li>钩子函数的名称都是Vue中规定好的！</li>
</ul>
<h3 id="钩子函数-beforeCreate"><a href="#钩子函数-beforeCreate" class="headerlink" title="钩子函数 - beforeCreate()"></a>钩子函数 - beforeCreate()</h3><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用<br>注意：此时，无法获取 data中的数据、methods中的方法</p>
<h3 id="钩子函数-created"><a href="#钩子函数-created" class="headerlink" title="钩子函数 - created()"></a>钩子函数 - created()</h3><p>注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 <a href="https://segmentfault.com/a/1190000008879966" target="_blank" rel="noopener">参考资料1</a> <a href="https://segmentfault.com/a/1190000008010666" target="_blank" rel="noopener">参考资料2</a></p>
<h3 id="钩子函数-beforeMounted"><a href="#钩子函数-beforeMounted" class="headerlink" title="钩子函数 - beforeMounted()"></a>钩子函数 - beforeMounted()</h3><p>在挂载开始之前被调用</p>
<h3 id="钩子函数-mounted"><a href="#钩子函数-mounted" class="headerlink" title="钩子函数 - mounted()"></a>钩子函数 - mounted()</h3><p>此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作</p>
<h3 id="钩子函数-beforeUpdated"><a href="#钩子函数-beforeUpdated" class="headerlink" title="钩子函数 - beforeUpdated()"></a>钩子函数 - beforeUpdated()</h3><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。<br>注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的</p>
<h3 id="钩子函数-updated"><a href="#钩子函数-updated" class="headerlink" title="钩子函数 - updated()"></a>钩子函数 - updated()</h3><p>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</p>
<h3 id="钩子函数-beforeDestroy"><a href="#钩子函数-beforeDestroy" class="headerlink" title="钩子函数 - beforeDestroy()"></a>钩子函数 - beforeDestroy()</h3><p>实例销毁之前调用。在这一步，实例仍然完全可用。<br>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</p>
<h3 id="钩子函数-destroyed"><a href="#钩子函数-destroyed" class="headerlink" title="钩子函数 - destroyed()"></a>钩子函数 - destroyed()</h3><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><ul>
<li>Promise based HTTP client for the browser and node.js<ul>
<li>以Promise为基础的HTTP客户端，适用于：浏览器和node.js</li>
<li>封装ajax，用来发送请求，异步获取数据</li>
</ul>
</li>
<li>安装：npm i -S axios</li>
<li>拦截器：拦截器会拦截发送的每一个请求，请求发送之前执行request中的函数，请求发送完成之后执行response中的函数</li>
</ul>
<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><ul>
<li>作用：进行DOM操作</li>
<li>使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点</li>
<li>两种指令：1 全局指令 2 局部指令</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote>
<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p>
</blockquote>
<p>创建组件的两种方式：1 全局组件 2 局部组件</p>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><ul>
<li>说明：全局组件在所有的vue实例中都可以使用</li>
<li>注意：先注册组件，再初始化根实例</li>
<li>extend：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li>
</ul>
<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用</p>
<h3 id="is特性"><a href="#is特性" class="headerlink" title="is特性"></a>is特性</h3><blockquote>
<p>在某些特定的标签中只能存在指定表恰 如ul &gt; li 如果要浏览器正常解析则需要使用is</p>
</blockquote>
<h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><h3 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h3><p>通过子组件props属性来传递数据 props是一个数组, 传递过来的props属性的用法与data属性的用法相同<br>注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效</p>
<h3 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h3><p>父组件给子组件传递一个函数，由子组件调用这个函数。借助vue中的自定义事件（v-on:cunstomFn=”fn”）<br>步骤：</p>
<ol>
<li>在父组件中定义方法 parentFn</li>
<li>在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=”父组件中的方法” ==&gt; @pfn=”parentFn”</li>
<li>子组件中通过$emit()触发自定义事件事件 this.$emit(pfn,参数列表。。。)</li>
</ol>
<h3 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h3><blockquote>
<p>在简单的场景下，可以使用一个空的 Vue 实例作为事件总线<br>$on()：绑定自定义事件</p>
</blockquote>
<h3 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h3><p>通过<slot></slot> 标签指定内容展示区域</p>
<h3 id="获取组件（或元素）-refs"><a href="#获取组件（或元素）-refs" class="headerlink" title="获取组件（或元素） - refs"></a>获取组件（或元素） - refs</h3><p>vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）.在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取<br>注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods</p>
<h2 id="SPA-单页应用程序"><a href="#SPA-单页应用程序" class="headerlink" title="SPA -单页应用程序"></a>SPA -单页应用程序</h2><h3 id="SPA：-Single-Page-Application"><a href="#SPA：-Single-Page-Application" class="headerlink" title="SPA： Single Page Application"></a>SPA： Single Page Application</h3><blockquote>
<p>单页Web应用（single page application，SPA），就是只有一个Web页面的应用，是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。</p>
</blockquote>
<ul>
<li>单页面应用程序：只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中</li>
<li>传统多页面应用程序：对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面<br>优势:</li>
<li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>
<li>更好的用户体验，让用户在web app感受native app的流畅<br>实现思路和技术点</li>
</ul>
<ol>
<li>ajax</li>
<li>锚点的使用（window.location.hash #）</li>
<li>hashchange 事件 window.addEventListener(“hashchange”,function () {})</li>
<li>监听锚点值变化的事件，根据不同的锚点值，请求相应的数据</li>
<li>原本用作页面内部进行跳转，定位并展示相应的内容</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由即：浏览器中的哈希值（# hash）与展示视图内容（template）之间的对应规则<br>vue中的路由是：hash 和 component的对应关系,在 Web app 中，通过一个页面来展示和管理整个应用的功能。SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容<br>基本使用 安装：npm i -S vue-router<br>重定向 { path: ‘/‘, redirect: ‘/home’ }<br>路由其他配置 </p>
<ul>
<li>路由导航高亮 当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类</li>
<li>匹配路由模式 配置：mode<br>路由参数</li>
<li>说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理</li>
<li>语法：/user/:id</li>
<li>使用：当匹配到一个路由时，参数值会被设置到 this.$route.params</li>
<li>其他：可以通过 $route.query 获取到 URL 中的查询参数 等<br>嵌套路由 - 子路由</li>
<li>路由是可以嵌套的，即：路由中又包含子路由</li>
<li>规则：父组件中包含 router-view，在路由规则中使用 children 配置</li>
</ul>
<h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><p>为什么需要模块化?</p>
<ol>
<li>最开始的js就是为了实现客户端验证以及一些简单的效果</li>
<li>后来，js得到重视，应用越来越广泛，前端开发的复杂度越来越高</li>
<li>旧版本的js中没有提供与模块（module）相关的内容<h3 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h3></li>
</ol>
<ul>
<li>在js中，一个模块就是实现特定功能的文件（js文件）</li>
<li>遵循模块的机制，想要什么功能就加载什么模块</li>
<li>模块化开发需要遵循规范</li>
</ul>
<h3 id="模块化解决的问题"><a href="#模块化解决的问题" class="headerlink" title="模块化解决的问题"></a>模块化解决的问题</h3><ol>
<li>命名冲突</li>
<li>文件依赖（加载文件）</li>
<li>模块的复用</li>
<li>统一规范和开发方式</li>
</ol>
<h3 id="JS实现模块化的规范"><a href="#JS实现模块化的规范" class="headerlink" title="JS实现模块化的规范"></a>JS实现模块化的规范</h3><p>AMD 的使用</p>
<blockquote>
<p>Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范 代表：require.js 特点：模块被异步加载，模块加载不影响后面语句的运行</p>
</blockquote>
<ol>
<li><p>定义模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 语法:define(name, dependencies?, factory);</span><br><span class="line">// name表示：当前模块的名称，是一个字符串 可有可无</span><br><span class="line">// dependencies表示：当前模块的依赖项，是一个数组无论依赖一项还是多项 无则不写</span><br><span class="line">// factory表示：当前模块要完成的一些功能，是一个函数</span><br><span class="line"></span><br><span class="line">// 定义对象模块</span><br><span class="line">define(&#123;&#125;)</span><br><span class="line">// 定义方法模块</span><br><span class="line">define(function() &#123;</span><br><span class="line">  return &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 定义带有依赖项的模块</span><br><span class="line">define([&apos;js/a&apos;], function() &#123;&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// - 注意：require的第一个参数必须是数组</span><br><span class="line"></span><br><span class="line">// 参数必须是数组 表示模块路径 以当前文件为基准,通过回调函数中的参数获取加载模块中的变量 参数与模块按照顺序一一对应</span><br><span class="line">require([&apos;a&apos;, &apos;js/b&apos;], function(a, b) &#123;</span><br><span class="line">  // 使用模块a 和 模块b 中的代码</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>路径查找配置</p>
<ul>
<li>requirejs 默认使用 baseUrl+paths 的路径解析方式</li>
<li>可以使用以下方式避开此设置：1 以.js结尾 2 以 / 开始 3 包含协议：https:// 或 http://<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 配置示例</span><br><span class="line">// 注意配置应当在使用之前</span><br><span class="line">require.config(&#123;</span><br><span class="line">  baseUrl: &apos;./js&apos; // 配置基础路径为：当前目录下的js目录</span><br><span class="line">&#125;)</span><br><span class="line">require([&apos;a&apos;])    // 查找 基础路径下的 ./js/a.js</span><br><span class="line"></span><br><span class="line">// 简化加载模块路径</span><br><span class="line">require.config(&#123;</span><br><span class="line">  baseUrl: &apos;./js&apos;,</span><br><span class="line">  // 配置一次即可，直接通过路径名称（template || jquery）加载模块</span><br><span class="line">  paths: &#123;</span><br><span class="line">    template: &apos;assets/artTemplate/template-native&apos;,</span><br><span class="line">    jquery: &apos;assets/jquery/jquery.min&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 加载jquery template模块</span><br><span class="line">require([&apos;jquery&apos;, &apos;template&apos;])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>非模块化和依赖项支持</p>
<ul>
<li>添加模块的依赖模块，保证加载顺序（deps）</li>
<li>将非模块化模块，转化为模块化（exports）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">require.config(&#123;</span><br><span class="line">  baseUrl: &apos;./js&apos;,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    // 配置路径</span><br><span class="line">    noModule: &apos;assets/demo/noModule&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 配置不符合规范的模块项</span><br><span class="line">  shim: &#123;</span><br><span class="line">    // 模块名称</span><br><span class="line">    noModule: &#123;</span><br><span class="line">      deps: [],         // 依赖项</span><br><span class="line">      exports: &apos;sayHi&apos;  // 导出模块中存在的函数或变量</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 注意点  如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块</span><br><span class="line">// 定义 这个模块名称与paths中的名称相同</span><br><span class="line">define(&apos;moduleA&apos;, function() &#123;&#125;)</span><br><span class="line">// 导入</span><br><span class="line">require.config(&#123;</span><br><span class="line">  paths: &#123;</span><br><span class="line">    // 此处的模块名：moduleA</span><br><span class="line">    moduleA: &apos;assets/demo/moduleA&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>路径加载规则<br>路径配置的优先级：1 通过 config 配置规则查找 2 通过 data-main 指定的路径查找 3 以引入 requirejs 的页面所在路径为准查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">  设置data-main属性</span><br><span class="line">  1 data-main属性指定的文件也会同时被加载</span><br><span class="line">  2 用于指定查找其他模块的基础路径</span><br><span class="line">--&gt;</span><br><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陆阿狸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/05/29/vue学习/">http://yoursite.com/2019/05/29/vue学习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">陆阿狸的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/微信打赏.png"><div class="post-qr-code__desc">喜欢的话支持一下？</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/支付宝打赏.png"><div class="post-qr-code__desc">喜欢的话支持一下？</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/05/31/前端需要知道的Javascript技巧/"><i class="fa fa-chevron-left">  </i><span>前端需要知道的Javascript技巧</span></a></div><div class="next-post pull-right"><a href="/2019/05/28/【JS进阶】你真的掌握变量和类型了吗/"><span>【JS进阶】你真的掌握变量和类型了吗</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/sky.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By 陆阿狸</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>