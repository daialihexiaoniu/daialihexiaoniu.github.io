<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
  
  <title>vue学习 - 陆阿黎的博客</title>
  <meta charset="UTF-8">
  <meta name="description" content="天天撸狗，天天快乐">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/img/my-favicon.ico" type="image/png">
  <meta name="description" content="记录 Vue 的学习, Vue -渐进式JavaScript框架">
<meta name="keywords" content="vue">
<meta property="og:type" content="article">
<meta property="og:title" content="vue学习">
<meta property="og:url" content="http://yoursite.com/2019/05/29/vue学习/index.html">
<meta property="og:site_name" content="陆阿黎的博客">
<meta property="og:description" content="记录 Vue 的学习, Vue -渐进式JavaScript框架">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-09-18T09:03:19.254Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue学习">
<meta name="twitter:description" content="记录 Vue 的学习, Vue -渐进式JavaScript框架">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1569822173461">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/img/sky.png)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="陆阿黎" class="mdui-btn mdui-btn-icon"><img src="/img/avatar.jpg"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="陆阿黎">
            <img src="/img/avatar.jpg" alt="陆阿黎">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>18</div>
        <div><span>标签</span>9</div>
        <div><span>分类</span>3</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/7666533" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/daialihexiaoniu/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CSS/">CSS</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JS/">JS</a>
          <span class="category-list-count">15</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/杂记/">杂记</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/ES10/" style="font-size: 10px;">ES10</a> <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/hexo/" style="font-size: 16.67px;">hexo</a> <a href="/tags/js知识/" style="font-size: 20px;">js知识</a> <a href="/tags/vue/" style="font-size: 13.33px;">vue</a> <a href="/tags/杂记/" style="font-size: 10px;">杂记</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 陆阿黎
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    <div class="nexmoe-post-cover"> 
        
            <img src="/img/sky.png">
        
        <h1>vue学习</h1>
    </div>
  <div class="nexmoe-post-meta">
    <a><i class="nexmoefont icon-calendar-fill"></i>2019年05月29日</a>
    <a><i class="nexmoefont icon-areachart"></i>4k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
    
      <a class="nexmoefont icon-appstore-fill -link" href="/categories/JS/">JS</a>
    
    
      <a class="nexmoefont icon-tag-fill -link" href="/tags/vue/">vue</a>
    
  </div>
  <article>
    <blockquote>
<p>记录 Vue 的学习, Vue -渐进式JavaScript框架</p>
</blockquote>
<a id="more"></a>
<h2 id="MVC-与-MVVM-的区别"><a href="#MVC-与-MVVM-的区别" class="headerlink" title="MVC 与 MVVM 的区别"></a>MVC 与 MVVM 的区别</h2><p>MVC 是指 Model View Controller（模型-视图-控制器），是一种 Web 架构的模式。<br>MVVM 是指 Model-View-ViewModel，是一种基于前端开发的架构模式。<br>在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。<br>MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。</p>
<h2 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h2><p><b>注意点：</b></p>
<ol>
<li>需要先在data中声明数据，再使用数据</li>
<li>可以通过 vm.$data 访问到data中的所有属性，或者 vm.msg</li>
</ol>
<h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响。通过 getter 和 setter 来实现双向绑定</p>
<h2 id="动态添加数据的注意点"><a href="#动态添加数据的注意点" class="headerlink" title="动态添加数据的注意点"></a>动态添加数据的注意点</h2><p>只有 data 中的数据才是响应式的，动态添加进来的数据默认为非响应式<br>可以通过以下方式实现动态添加数据的响应式</p>
<ol>
<li>Vue.set(object, key, value) - 适用于添加单个属性</li>
<li>Object.assign() - 适用于添加多个属性</li>
</ol>
<h2 id="异步-DOM-更新"><a href="#异步-DOM-更新" class="headerlink" title="异步 DOM 更新"></a>异步 DOM 更新</h2><ul>
<li>说明：Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM</li>
<li>优势：可以去除重复数据，对于避免不必要的计算和避免重复 DOM 操作上，非常重要</li>
<li>如果需要那到更新后 DOM 中的数据，则需要通过 Vue.nextTick(callback)：在DOM更新后，执行某个操作（属于DOM操作） 实例调用 vm.$nextTick(function () {})</li>
</ul>
<h2 id="Vue-指令"><a href="#Vue-指令" class="headerlink" title="Vue 指令"></a>Vue 指令</h2><p>Vue 指令一般是带有 v- 前缀的特殊属性，当表达式的值改变是，将其产生的连带影响，响应式地作用于 DOM</p>
<ul>
<li>v-text: 更新 DOM 对象的 textContent</li>
<li>v-html: 更新 DOM 对象的 innerHTML</li>
<li>v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>
<li>v-on: 绑定事件， 绑定的事件定义在 methods 中</li>
<li>事件修饰符<ul>
<li>.stop 阻止冒泡，调用 event.stopPropagation()</li>
<li>.prevent 阻止默认行为，调用 event.preventDefault()</li>
<li>.capture 添加事件侦听器时使用事件捕获模式</li>
<li>.self 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件</li>
<li>.once 事件只触发一次</li>
</ul>
</li>
<li>v-model: 在表单元素上创建双向数据绑定，监听用户的输入事件以更新数据</li>
<li>v-for: 基于源数据多次渲染元素或模板块</li>
<li>key属性: 使用 v-for 的时候提供 key 属性，以获得性能提升。使用 key，Vue 会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li>
</ul>
<h2 id="样式处理-class-和-style"><a href="#样式处理-class-和-style" class="headerlink" title="样式处理 -class 和 style"></a>样式处理 -class 和 style</h2><p>使用方式：v-bind:class=”expression” or :class=”expression”， 表达式的类型：字符串、数组、对象（重点）</p>
<ul>
<li><p>v-if 和 v-show</p>
<ul>
<li>v-if: 根据表达式的值的真假条件，销毁或重建元素</li>
<li>v-show: 根据表达式之真假值，切换元素的 display CSS 属性</li>
</ul>
</li>
<li><p>提升性能: v-pre<br>vue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译</p>
</li>
<li><p>提升性能：v-once<br>vue只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>
</li>
</ul>
<h2 id="过滤器-filter"><a href="#过滤器-filter" class="headerlink" title="过滤器 filter"></a>过滤器 filter</h2><p>文本数据格式化</p>
<ul>
<li>全局过滤器<br>通过全局方式创建的过滤器，在任何一个vue实例中都可以使用。使用全局过滤器的时候，需要先创建全局过滤器，再创建Vue实例。显示的内容由过滤器的返回值决定</li>
<li>局部过滤器<br>局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用</li>
</ul>
<h2 id="按键值修饰符"><a href="#按键值修饰符" class="headerlink" title="按键值修饰符"></a>按键值修饰符</h2><p>在监听键盘事件时，Vue 允许为 v-on 在监听键盘事件时添加关键修饰符。例如@keyup.13=”submit”</p>
<h2 id="监视数据变化-watch"><a href="#监视数据变化-watch" class="headerlink" title="监视数据变化 - watch"></a>监视数据变化 - watch</h2><p>watch是一个对象，键是需要观察的表达式，值是对应回调函数，当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作</p>
<h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><p>所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。<br>实例生命周期也叫做：组件生命周期</p>
<h3 id="生命周期介绍"><a href="#生命周期介绍" class="headerlink" title="生命周期介绍"></a>生命周期介绍</h3><p>一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期<br>生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！<br>注意：</p>
<ul>
<li>Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可</li>
<li>钩子函数的名称都是Vue中规定好的！</li>
</ul>
<h3 id="钩子函数-beforeCreate"><a href="#钩子函数-beforeCreate" class="headerlink" title="钩子函数 - beforeCreate()"></a>钩子函数 - beforeCreate()</h3><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用<br>注意：此时，无法获取 data中的数据、methods中的方法</p>
<h3 id="钩子函数-created"><a href="#钩子函数-created" class="headerlink" title="钩子函数 - created()"></a>钩子函数 - created()</h3><p>注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 <a href="https://segmentfault.com/a/1190000008879966" target="_blank" rel="noopener">参考资料1</a> <a href="https://segmentfault.com/a/1190000008010666" target="_blank" rel="noopener">参考资料2</a></p>
<h3 id="钩子函数-beforeMounted"><a href="#钩子函数-beforeMounted" class="headerlink" title="钩子函数 - beforeMounted()"></a>钩子函数 - beforeMounted()</h3><p>在挂载开始之前被调用</p>
<h3 id="钩子函数-mounted"><a href="#钩子函数-mounted" class="headerlink" title="钩子函数 - mounted()"></a>钩子函数 - mounted()</h3><p>此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作</p>
<h3 id="钩子函数-beforeUpdated"><a href="#钩子函数-beforeUpdated" class="headerlink" title="钩子函数 - beforeUpdated()"></a>钩子函数 - beforeUpdated()</h3><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。<br>注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的</p>
<h3 id="钩子函数-updated"><a href="#钩子函数-updated" class="headerlink" title="钩子函数 - updated()"></a>钩子函数 - updated()</h3><p>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</p>
<h3 id="钩子函数-beforeDestroy"><a href="#钩子函数-beforeDestroy" class="headerlink" title="钩子函数 - beforeDestroy()"></a>钩子函数 - beforeDestroy()</h3><p>实例销毁之前调用。在这一步，实例仍然完全可用。<br>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</p>
<h3 id="钩子函数-destroyed"><a href="#钩子函数-destroyed" class="headerlink" title="钩子函数 - destroyed()"></a>钩子函数 - destroyed()</h3><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><ul>
<li>Promise based HTTP client for the browser and node.js<ul>
<li>以Promise为基础的HTTP客户端，适用于：浏览器和node.js</li>
<li>封装ajax，用来发送请求，异步获取数据</li>
</ul>
</li>
<li>安装：npm i -S axios</li>
<li>拦截器：拦截器会拦截发送的每一个请求，请求发送之前执行request中的函数，请求发送完成之后执行response中的函数</li>
</ul>
<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><ul>
<li>作用：进行DOM操作</li>
<li>使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点</li>
<li>两种指令：1 全局指令 2 局部指令</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote>
<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p>
</blockquote>
<p>创建组件的两种方式：1 全局组件 2 局部组件</p>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><ul>
<li>说明：全局组件在所有的vue实例中都可以使用</li>
<li>注意：先注册组件，再初始化根实例</li>
<li>extend：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li>
</ul>
<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用</p>
<h3 id="is特性"><a href="#is特性" class="headerlink" title="is特性"></a>is特性</h3><blockquote>
<p>在某些特定的标签中只能存在指定表恰 如ul &gt; li 如果要浏览器正常解析则需要使用is</p>
</blockquote>
<h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><h3 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h3><p>通过子组件props属性来传递数据 props是一个数组, 传递过来的props属性的用法与data属性的用法相同<br>注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效</p>
<h3 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h3><p>父组件给子组件传递一个函数，由子组件调用这个函数。借助vue中的自定义事件（v-on:cunstomFn=”fn”）<br>步骤：</p>
<ol>
<li>在父组件中定义方法 parentFn</li>
<li>在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=”父组件中的方法” ==&gt; @pfn=”parentFn”</li>
<li>子组件中通过$emit()触发自定义事件事件 this.$emit(pfn,参数列表。。。)</li>
</ol>
<h3 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h3><blockquote>
<p>在简单的场景下，可以使用一个空的 Vue 实例作为事件总线<br>$on()：绑定自定义事件</p>
</blockquote>
<h3 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h3><p>通过<slot></slot> 标签指定内容展示区域</p>
<h3 id="获取组件（或元素）-refs"><a href="#获取组件（或元素）-refs" class="headerlink" title="获取组件（或元素） - refs"></a>获取组件（或元素） - refs</h3><p>vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）.在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取<br>注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods</p>
<h2 id="SPA-单页应用程序"><a href="#SPA-单页应用程序" class="headerlink" title="SPA -单页应用程序"></a>SPA -单页应用程序</h2><h3 id="SPA：-Single-Page-Application"><a href="#SPA：-Single-Page-Application" class="headerlink" title="SPA： Single Page Application"></a>SPA： Single Page Application</h3><blockquote>
<p>单页Web应用（single page application，SPA），就是只有一个Web页面的应用，是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。</p>
</blockquote>
<ul>
<li>单页面应用程序：只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中</li>
<li>传统多页面应用程序：对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面<br>优势:</li>
<li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>
<li>更好的用户体验，让用户在web app感受native app的流畅<br>实现思路和技术点</li>
</ul>
<ol>
<li>ajax</li>
<li>锚点的使用（window.location.hash #）</li>
<li>hashchange 事件 window.addEventListener(“hashchange”,function () {})</li>
<li>监听锚点值变化的事件，根据不同的锚点值，请求相应的数据</li>
<li>原本用作页面内部进行跳转，定位并展示相应的内容</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由即：浏览器中的哈希值（# hash）与展示视图内容（template）之间的对应规则<br>vue中的路由是：hash 和 component的对应关系,在 Web app 中，通过一个页面来展示和管理整个应用的功能。SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容<br>基本使用 安装：npm i -S vue-router<br>重定向 { path: ‘/‘, redirect: ‘/home’ }<br>路由其他配置 </p>
<ul>
<li>路由导航高亮 当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类</li>
<li>匹配路由模式 配置：mode<br>路由参数</li>
<li>说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理</li>
<li>语法：/user/:id</li>
<li>使用：当匹配到一个路由时，参数值会被设置到 this.$route.params</li>
<li>其他：可以通过 $route.query 获取到 URL 中的查询参数 等<br>嵌套路由 - 子路由</li>
<li>路由是可以嵌套的，即：路由中又包含子路由</li>
<li>规则：父组件中包含 router-view，在路由规则中使用 children 配置</li>
</ul>
<h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><p>为什么需要模块化?</p>
<ol>
<li>最开始的js就是为了实现客户端验证以及一些简单的效果</li>
<li>后来，js得到重视，应用越来越广泛，前端开发的复杂度越来越高</li>
<li>旧版本的js中没有提供与模块（module）相关的内容<h3 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h3></li>
</ol>
<ul>
<li>在js中，一个模块就是实现特定功能的文件（js文件）</li>
<li>遵循模块的机制，想要什么功能就加载什么模块</li>
<li>模块化开发需要遵循规范</li>
</ul>
<h3 id="模块化解决的问题"><a href="#模块化解决的问题" class="headerlink" title="模块化解决的问题"></a>模块化解决的问题</h3><ol>
<li>命名冲突</li>
<li>文件依赖（加载文件）</li>
<li>模块的复用</li>
<li>统一规范和开发方式</li>
</ol>
<h3 id="JS实现模块化的规范"><a href="#JS实现模块化的规范" class="headerlink" title="JS实现模块化的规范"></a>JS实现模块化的规范</h3><p>AMD 的使用</p>
<blockquote>
<p>Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范 代表：require.js 特点：模块被异步加载，模块加载不影响后面语句的运行</p>
</blockquote>
<ol>
<li><p>定义模块</p>
<pre><code> // 语法:define(name, dependencies?, factory);
 // name表示：当前模块的名称，是一个字符串 可有可无
 // dependencies表示：当前模块的依赖项，是一个数组无论依赖一项还是多项 无则不写
 // factory表示：当前模块要完成的一些功能，是一个函数

 // 定义对象模块
 define({})
 // 定义方法模块
 define(function() {
   return {}
 })
 // 定义带有依赖项的模块
 define([&#39;js/a&#39;], function() {})
</code></pre></li>
<li><p>加载模块</p>
<pre><code> // - 注意：require的第一个参数必须是数组

 // 参数必须是数组 表示模块路径 以当前文件为基准,通过回调函数中的参数获取加载模块中的变量 参数与模块按照顺序一一对应
 require([&#39;a&#39;, &#39;js/b&#39;], function(a, b) {
   // 使用模块a 和 模块b 中的代码
 })
</code></pre></li>
<li><p>路径查找配置</p>
<ul>
<li>requirejs 默认使用 baseUrl+paths 的路径解析方式</li>
<li><p>可以使用以下方式避开此设置：1 以.js结尾 2 以 / 开始 3 包含协议：https:// 或 http://</p>
<pre><code>// 配置示例
// 注意配置应当在使用之前
require.config({
baseUrl: &#39;./js&#39; // 配置基础路径为：当前目录下的js目录
})
require([&#39;a&#39;])    // 查找 基础路径下的 ./js/a.js

// 简化加载模块路径
require.config({
baseUrl: &#39;./js&#39;,
// 配置一次即可，直接通过路径名称（template || jquery）加载模块
paths: {
  template: &#39;assets/artTemplate/template-native&#39;,
  jquery: &#39;assets/jquery/jquery.min&#39;
}
})
// 加载jquery template模块
require([&#39;jquery&#39;, &#39;template&#39;])
</code></pre></li>
</ul>
</li>
<li><p>非模块化和依赖项支持</p>
<ul>
<li>添加模块的依赖模块，保证加载顺序（deps）</li>
<li><p>将非模块化模块，转化为模块化（exports）</p>
<pre><code>// 示例
require.config({
baseUrl: &#39;./js&#39;,
paths: {
  // 配置路径
  noModule: &#39;assets/demo/noModule&#39;
},
// 配置不符合规范的模块项
shim: {
  // 模块名称
  noModule: {
    deps: [],         // 依赖项
    exports: &#39;sayHi&#39;  // 导出模块中存在的函数或变量
  }
}
});

// 注意点  如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块
// 定义 这个模块名称与paths中的名称相同
define(&#39;moduleA&#39;, function() {})
// 导入
require.config({
paths: {
  // 此处的模块名：moduleA
  moduleA: &#39;assets/demo/moduleA&#39;
}
})
</code></pre></li>
</ul>
</li>
<li><p>路径加载规则<br>路径配置的优先级：1 通过 config 配置规则查找 2 通过 data-main 指定的路径查找 3 以引入 requirejs 的页面所在路径为准查找</p>
<pre><code> &lt;!-- 
   设置data-main属性
   1 data-main属性指定的文件也会同时被加载
   2 用于指定查找其他模块的基础路径
 --&gt;
 &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;
</code></pre></li>
</ol>

  </article>
  
    
<div class="nexmoe-post-copyright">
<i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
<strong>本文作者：</strong>陆阿黎<br>
<strong>本文链接：</strong><a href="http://yoursite.com/2019/05/29/vue学习/" title="http://yoursite.com/2019/05/29/vue学习/" target="_blank" rel="noopener">http://yoursite.com/2019/05/29/vue学习/</a><br>

  <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

</div>


  
  <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '6a32b32016b52f34d75a',
        clientSecret: '02e131713b96def0aba672c34d002467ec247c1d',
        id: decodeURI(window.location.pathname),
        repo: 'daialihexiaoniu.github.io',
        owner: 'daialihexiaoniu',
        admin: 'daialihexiaoniu'
    })
    gitalk.render('gitalk')
</script>
</section>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1569822173473"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>


    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>

  





</body>

</html>
